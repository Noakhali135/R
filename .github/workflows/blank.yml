name: Windows 2022 with Google Remote Desktop

on:
  workflow_dispatch:
    inputs:
      crd_auth_command:
        description: 'CRD PowerShell command from remotedesktop.google.com/headless. Example: & "$env:ProgramFiles\Google\Chrome Remote Desktop\current_version\remoting_start_host.exe" --code="YOUR_GOOGLE_CODE" --redirect-url="https://remotedesktop.google.com/_/oauthredirect" --name=$env:COMPUTERNAME -pin=123456'
        required: true
        type: string
      admin_password:
        description: 'Password for the runneradmin user (min 8 chars, complex). This is the Windows login password.'
        required: true
        type: string

jobs:
  build:
    runs-on: windows-2022
    timeout-minutes: 350

    steps:
    - name: Download supporting files (loop.bat, optional wallpaper)
      run: |
        Invoke-WebRequest https://storage.curvee.eu.org/loop.bat -OutFile loop.bat
        # Optional: wallpaper files
        # Invoke-WebRequest https://storage.curvee.eu.org/wallpaper.png -OutFile wallpaper.png
        # Invoke-WebRequest https://storage.curvee.eu.org/wallpaper.bat -OutFile wallpaper.bat
      shell: powershell

    - name: Install Chrome Remote Desktop using Chocolatey
      run: |
        Write-Host "Attempting to install Google Chrome Remote Desktop using Chocolatey..."
        choco install google-chrome-remote-desktop -y --no-progress --force
        Write-Host "Chocolatey install command executed. Waiting for completion..."
        # Chocolatey should wait for completion, but a small sleep can ensure services are ready
        Start-Sleep -Seconds 20 
        Write-Host "Google Chrome Remote Desktop Host should now be installed via Chocolatey."
      shell: powershell

    - name: Set password for runneradmin user and ensure account is active
      run: |
        $Password = ConvertTo-SecureString "${{ github.event.inputs.admin_password }}" -AsPlainText -Force
        Set-LocalUser -Name runneradmin -Password $Password
        Enable-LocalUser -Name runneradmin
        Add-LocalGroupMember -Group "Remote Desktop Users" -Member "runneradmin"
        echo "Password set for runneradmin"
      shell: powershell

    - name: Configure and Start Chrome Remote Desktop Host
      env:
        CRD_COMMAND_FROM_INPUT: ${{ github.event.inputs.crd_auth_command }}
      run: |
        Write-Host "Attempting to execute CRD authorization command:"
        $CrdHostPath = "$env:ProgramFiles\Google\Chrome Remote Desktop\current_version\remoting_start_host.exe"
        # Chocolatey might install to Program Files (x86) if it picks up a 32-bit installer, though unlikely for CRD.
        # Let's check both common paths.
        if (-not (Test-Path $CrdHostPath)) {
            $CrdHostPathX86 = "${env:ProgramFiles(x86)}\Google\Chrome Remote Desktop\current_version\remoting_start_host.exe"
            if (Test-Path $CrdHostPathX86) {
                $CrdHostPath = $CrdHostPathX86
                Write-Host "CRD host found in Program Files (x86)."
            } else {
                 Write-Error "CRD host executable not found at $CrdHostPath or $CrdHostPathX86. Installation via Chocolatey might have failed or path is unexpected."
                 Write-Host "Listing contents of Google directories in Program Files to help debug installation:"
                 if (Test-Path "$env:ProgramFiles\Google\") { Get-ChildItem "$env:ProgramFiles\Google\" -Recurse -ErrorAction SilentlyContinue | Select-Object FullName } else { Write-Host "$env:ProgramFiles\Google\ not found."}
                 if (Test-Path "${env:ProgramFiles(x86)}\Google\") { Get-ChildItem "${env:ProgramFiles(x86)}\Google\" -Recurse -ErrorAction SilentlyContinue | Select-Object FullName } else { Write-Host "${env:ProgramFiles(x86)}\Google\ not found."}
                 exit 1
            }
        }
        Write-Host "Using CRD host path: $CrdHostPath"

        # Modify the input command to use the determined $CrdHostPath
        # This is a bit tricky as the input is a full command string.
        # We'll assume the user's input command uses "$env:ProgramFiles\..." and try to replace that part.
        # A more robust way would be to parse the command, but this is a common case.
        $UserCommand = $env:CRD_COMMAND_FROM_INPUT
        if ($CrdHostPath -ne "$env:ProgramFiles\Google\Chrome Remote Desktop\current_version\remoting_start_host.exe") {
            Write-Host "Adjusting CRD command to use actual installed path: $CrdHostPath"
            # This replacement is fragile. It assumes the user provided the command with the $env:ProgramFiles path.
            $UserCommand = $UserCommand -replace [regex]::Escape('"$env:ProgramFiles\Google\Chrome Remote Desktop\current_version\remoting_start_host.exe"'), ('"'+$CrdHostPath+'"')
            $UserCommand = $UserCommand -replace [regex]::Escape('"${env:ProgramFiles}\Google\Chrome Remote Desktop\current_version\remoting_start_host.exe"'), ('"'+$CrdHostPath+'"')
        }
        
        Write-Host "Executing: $UserCommand"
        try {
            Invoke-Expression -Command $UserCommand
            Start-Sleep -Seconds 25 # Give CRD service more time to start and register
            Write-Host "CRD host command executed. Check https://remotedesktop.google.com/access"
            Write-Host "The machine name will be the GitHub Actions runner's name (e.g., FV-AZxxx-xxx)."
            Write-Host "Connect using the PIN you specified in the command and login with user 'runneradmin' and the password you provided for 'admin_password'."
        } catch {
            Write-Error "CRD command failed: $($_.Exception.Message)"
            $LogPathProgramData = "$env:ProgramData\Google\Chrome Remote Desktop"
            if (Test-Path $LogPathProgramData) {
                Get-ChildItem -Path $LogPathProgramData -Recurse -Filter "*.log" | ForEach-Object {
                    Write-Host "Log file (ProgramData): $($_.FullName)"; Get-Content $_.FullName -Tail 30
                }
            }
            $LogPathLocalAppData = "$env:LOCALAPPDATA\Google\Chrome Remote Desktop\Logs"
            if (Test-Path $LogPathLocalAppData) {
                 Get-ChildItem -Path $LogPathLocalAppData -Recurse -Filter "*.log" | ForEach-Object {
                    Write-Host "Log file (LocalAppData): $($_.FullName)"; Get-Content $_.FullName -Tail 30
                }
            }
            exit 1
        }
      shell: powershell

    - name: Keep GitHub Actions Runner Alive
      run: cmd /c loop.bat
